using System;
using System.Collections.Generic;
using System.IO;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

/* Configuration is defined in a YAML file:
 * 
 * ===============================
 *  
 *  apikey: abcdefghijklmnop       # API key generated by light bridge
 *  dispatchPeriod: 150            # Minimum delay (in ms) between dispatching messages to bridge
 *  groups:
 *    bedroom: [4]
 *    living room: [1, 2, 3]
 *    all: [1, 2, 3, 4]
 *  schedules:
 *    default:                     # Create a schedule named "default"
 *      elements:                  # list elements of the schedule
 *      - name: Morning            # Name this schedule element
 *        lights: bedroom          # which lighting group/alias this schedule affects
 *        days: [1, 2, 3, 4, 5]    # Effective on Mondays through Fridays (Sunday is 0, Saturday is 6)
 *        on: 7:00                 # Turn on at 7:00 AM (24-hour format)
 *        off: 7:15                # Turn off at 7:15 AM (24-hour format)
 *        ramp: 10                 # Ramp up brightness over 10 minutes
 *        brightness: 254          # Brightness of the bulb, from 1 (dim) to 254 (max brightness)
 *        colour: 350              # Colour temperature (for bulbs that support it), from 500 (2000K) to 153 (6500K)
 *      - name: Evening
 *        lights: living room
 *        days: [0, 1, 2, 3, 4, 5, 6]
 *        on: 19:00
 *        brightness: 254
 *        colour: 500
 *      - name: Night
 *        lights: all
 *        days: [0, 1, 2, 3, 4, 5, 6]
 *        off: 2:00
 *    away:
 *      inherit: default        # The "away" schedule is the same as "default"...
 *      elements:
 *      - name: Night             # ... except the "Night" schedule element
 *        off: 0:30               #     has its off time overwritten
 * 
 * ===============================
 * 
 * TODO: colour temperature, brightness, sunset trigger, randomized on/off
 *       default colour temperature/brightness based on time/sunset
 *       reload mechanism for config file (monitor filesystem?  timer?  button on UI?)
 *       change settings without changing light state
 */

namespace LightControl
{
    [Serializable]
    internal class ConfigValueException : Exception
    {
        internal string Field { get; private set; }
        internal object Value { get; private set; }
        internal ConfigValueException() : base() { }
        internal ConfigValueException(string msg) : base(msg) { }
        internal ConfigValueException(string msg, Exception inner) : base(msg, inner) { }
    }
    class Config
    {
        private ConfigSchema config;

        /// <summary>
        /// Load a configuration YAML file.
        /// </summary>
        /// <param name="filename">Path to the YAML file to load.</param>
        internal Config(string filename)
        {
            IDeserializer deserializer = new DeserializerBuilder().WithNamingConvention(new CamelCaseNamingConvention()).Build();
            TextReader reader = File.OpenText(filename);
            try
            {
                config = deserializer.Deserialize<ConfigSchema>(reader);
                Validate();
            }
            catch (YamlDotNet.Core.SyntaxErrorException)
            {
                // How are we handling errors?
            }
        }

        private void Validate()
        {
            if (ApiKey.Length <= 0 )
                throw new ConfigValueException(string.Format("Invalid API key length. (ApiKey = {0})", ApiKey.Length));
            if (DispatchPeriod < 150)
            {
                throw new ConfigValueException(string.Format("Dispatch period must be >150 ms. (DispatchPeriod = {0}", DispatchPeriod));
            }
            foreach (string key in Groups.Keys)
            {
                if (string.IsNullOrEmpty(key))
                    throw new ConfigValueException(string.Format("Group key cannot be empty. (key = {0})", key));
            }
            foreach (List<string> group in Groups.Values)
            {
                foreach (string id in group)
                {
                    if (!UInt32.TryParse(id, out uint _))
                    {
                        throw new ConfigValueException(string.Format("Group members must be integers. (Value was {0})", id));
                    }
                }
            }
            foreach (Schedule s in Schedules.Values)
            {
                foreach (ScheduleElement element in s.Elements)
                {
                    if (element.Brightness != null && (element.Brightness < 1 || element.Brightness > 254))
                        throw new ConfigValueException(string.Format("Brightness must be between 1 and 254 inclusive. (Value was {0})", element.Brightness));
                    if (element.Colour != null && (element.Colour < 153 || element.Colour > 500))
                        throw new ConfigValueException(string.Format("Colour must be between 153 (6500K) and 500 (2000K) inclusive. (Value was {0})", element.Colour));
                    if (element.On == null && element.Off == null)
                        throw new ConfigValueException(string.Format("Schedule element must specify On/Off time. (In element '{0}')", element.Name));
                    if (!new List<string>(Groups.Keys).Contains(element.Lights))
                        throw new ConfigValueException(string.Format("Unknown lighting group specified. (Group '{0}' in element '{1}')", element.Lights, element.Name));
                }
            }
        }
        
        internal string ApiKey => config.Apikey;
        internal int DispatchPeriod => config.Dispatchperiod;
        internal Dictionary<string, Schedule> Schedules => config.Schedules;
        internal Dictionary<string, List<string>> Groups => config.Groups;
    }

    public class ScheduleElement
    {
        public string Name { get; set; }
        public string Lights { get; set; }
        public List<int> Days { get; set; }
        public DateTime? On { get; set; } = null;
        public DateTime? Off { get; set; } = null;
        public uint Ramp { get; set; } = 0;
        public uint? Brightness { get; set; } = null;
        public uint? Colour { get; set; } = null;

        public ScheduleElement() { }
        public ScheduleElement(ScheduleElement old)
        {
            Name = old.Name;
            Lights = old.Lights;
            Days = new List<int>(old.Days);
            On = old.On;
            Off = old.Off;
            Ramp = old.Ramp;
            Brightness = old.Brightness;
            Colour = old.Colour;
        }
    }

    public class Schedule
    {
        public string Inherit { get; set; } = null;
        public List<ScheduleElement> Elements { get; set; } = new List<ScheduleElement>();

        public Schedule() { }
        public Schedule(Schedule old)
        {
            Inherit = old.Inherit;
            foreach (ScheduleElement e in old.Elements)
            {
                Elements.Add(new ScheduleElement(e));
            }
        }

        internal void AddElement(ScheduleElement newElement)
        {
            for (int i = 0; i < Elements.Count; i++)
            {
                if (Elements[i].Name == newElement.Name)
                {
                    // if there's already an element with this name, override any settings that are non-null in the new element
                    if (newElement.On != null) Elements[i].On = newElement.On;
                    if (newElement.Off != null) Elements[i].Off = newElement.Off;
                    if (newElement.Lights != null) Elements[i].Lights = newElement.Lights;
                    if (newElement.Days != null) Elements[i].Days = newElement.Days;
                    if (newElement.Ramp != 0) Elements[i].Ramp = newElement.Ramp;
                    if (newElement.Brightness != null) Elements[i].Brightness = newElement.Brightness;
                    if (newElement.Colour != null) Elements[i].Colour = newElement.Colour;
                    return;
                }
            }
            // Add as a new element if we're not overriding an existing one
            Elements.Add(new ScheduleElement(newElement));
        }
    }

    public class ConfigSchema
    {
        public string Apikey { get; set; }
        public int Dispatchperiod { get; set; } = 150;
        public Dictionary<string, List<string>> Groups { get; set; }
        public Dictionary<string, Schedule> Schedules { get; set; }
    }
}
